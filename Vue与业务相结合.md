#### 封装业务组件

##### 对iview的table进行二次封装
[实现链接](https://github.com/Zenas-He/aboutJS/blob/master/iview%E7%9A%84table%E7%BB%84%E4%BB%B6%E5%8C%85%E8%A3%85.md)  
功能：将获取数据的操作和翻页操作封装到组件当中，不需要再从外部调用；支持特定的作用域插槽，简化插槽语法和规范列表功能。  
亮点：
1. vue将父组件传入子组件的数据分为props和events，这里把获取数据的函数以props的形式传入，将整个数据流都封装在组件当中。比如，如果我使用on和emit调用获取数据的函数，这个过程是没有回调的，那么，除了列表数据，如果我有一个loading参数，在调用前给true，在调用之后给false，那么我需要通过一并传入调用状态的方式来更新loading参数，这无疑增加了父子组件之间的通信，增加了业务复杂度。
2. 通过watch监听查询参数的变化，并实时修改列表数据，听过监听实现业务的响应式。
3. 暴露refresh接口用于外部强制刷新，比如在修改行数据之后。
4. 为重要操作提供回调，增加组件的灵活性，为使用者提供更多的扩展。

##### 业务弹窗组件
[实现链接](https://github.com/Zenas-He/aboutJS/blob/master/Toast%E4%B8%9A%E5%8A%A1%E7%BB%84%E4%BB%B6.md)  
功能：将通用的弹窗封装到弹窗组件中，并通过函数调用展示需要的弹窗。  
亮点：
1. 整合业务弹窗，提高使用效率，同时减少重复开发，降低开发成本。
2. 通过函数调用执行component.$mount(body)来实现DOM节点的挂载，不需要在页面上写额外的弹窗组件。只需要调用接口就能展示弹窗，符合开发者的使用习惯。
上面所说如果在根节点上添加弹窗组件并配合vuex也能实现一样的效果，但是对该组件来说，也可以根据传入DOM节点信息来实现在任意的组件上挂载弹窗而不用在模板上加组件。
3. 该组件的使用类原生alert方法，能够减少开发者的学习成本，提高开发效率。
4. 通过render函数和作为容器的函数组件为弹窗保留添加自定义内容的能力。

##### 复杂组件下作用域插槽的使用
[实现链接](https://github.com/Zenas-He/aboutJS/blob/master/Vue%E5%9C%A8%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6%E4%B8%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8.md)  
功能：实现多层级的组件支持render或者作用域插槽（作用域插槽被解析成方法，而插槽被解析成dom，没法放到函数组件的render函数中），比如布局组件里套了一层无限滚动，里面是列表行数据，行数据的部分内容从作用域插槽得来。  
亮点：
1. 嵌套作用域插槽每层组件都要修改，维护工作量巨大，而使用Provide配合$scopeSlots能够跨层级获取得到作用域插槽的内容,便于组件的开发。

#### 抽象业务逻辑
功能：将通用的业务逻辑比如用户账号信息、用户设备状态、活动状态和jsbridge抽象到单独的混入当中，并且把数据放到vuex当中进行管理。  
亮点：
1. 和页面强关联的状态，像组件状态如加载状态放在单个组件中维护，页面状态如精选评论，可以放在组件或者页面中进行维护。而通用的用户账号信息等状态则放在vuex中，便于全局复用。
2. 将通用的业务状态抽象出来，然后利用混入相对独立的状态维护操作进行解耦，再根据需要引入相应的状态，进行通用业务和应用业务的组合。
